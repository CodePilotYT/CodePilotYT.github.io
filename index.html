<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Limestone Grid — Modular</title>
<style>
  html, body { margin:0; height:100%; background:#a8d0ff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial; }
  canvas { display:block; margin:0 auto; background:linear-gradient(#eaf8ff,#dff1ff); }
  #panel {
    position:absolute; top:10px; left:10px; width:260px;
    background:rgba(255,255,255,0.95); border-radius:10px; padding:10px;
    box-shadow:0 8px 24px rgba(0,0,0,0.15); z-index:10;
  }
  #panel h3 { margin:0 0 8px; }
  #controls { display:flex; gap:8px; margin-bottom:8px; flex-wrap:wrap; }
  button { padding:6px 10px; font-size:14px; cursor:pointer; }
  .row { margin:6px 0; }
  .label { font-size:13px; color:#333; display:flex; justify-content:space-between; }
  input[type="range"] { width:100%; }
  input[type="text"] { width:100%; padding:4px; font-size:12px; font-family:monospace; }
  #settingsHeader { margin:8px 0; cursor:pointer; font-weight:600; user-select:none; }
  #settings { display:none; }
  .small { font-size:12px; color:#555; }
  .seed-controls { display:flex; gap:4px; margin-top:4px; }
  .seed-controls button { padding:4px 8px; font-size:11px; }
</style>
</head>
<body>

<div id="panel">
  <h3>⚒️ Limestone Sim</h3>
  <div id="controls">
    <button id="startBtn">Start rain</button>
    <button id="resetBtn">Reset</button>
    <button id="fsBtn">Fullscreen</button>
  </div>

  <div id="settingsHeader" onclick="toggleSettings()">⚙️ Settings</div>
  <div id="settings">
    <div class="row">
      <div class="label"><span>Seed</span></div>
      <input type="text" id="seedInput" />
      <div class="seed-controls">
        <button id="copySeedBtn">Copy</button>
        <button id="applySeedBtn">Apply</button>
        <button id="randomSeedBtn">Random</button>
      </div>
    </div>
    <div class="row">
      <div class="label"><span>Rain</span><span id="rainVal">0.60</span></div>
      <input id="rainSlider" type="range" min="0" max="1" step="0.05" value="0.6" />
    </div>
    <div class="row">
      <div class="label"><span>Acid</span><span id="acidVal">1.0</span></div>
      <input id="acidSlider" type="range" min="0.5" max="3" step="0.1" value="1.0" />
    </div>
    <div class="row">
      <div class="label"><span>Block HP</span><span id="hpVal">16</span></div>
      <input id="hpSlider" type="range" min="5" max="40" step="1" value="16" />
    </div>
    <div class="row">
      <label class="small"><input type="checkbox" id="hpToggle" checked /> HP bars</label>
    </div>
    <div class="row">
      <label class="small"><input type="checkbox" id="debrisToggle" checked /> Debris</label>
    </div>
    <div class="row">
      <div class="label"><span>Water</span><span id="waterVal">0%</span></div>
    </div>
  </div>

  <div class="small">Click to spawn rain. Watch caves form!</div>
</div>

<canvas id="c" width="900" height="560"></canvas>

<script>
// ===== CONFIG =====
const cfg = {
  W: 900, H: 560,
  cols: 24, rows: 4, dirtRows: 2,
  blockH: 30,
  get blockW() { return this.W / this.cols },
  get groundY() { return this.H - (this.rows + this.dirtRows) * this.blockH }
};

// ===== STATE =====
const state = {
  raining: false,
  rainIntensity: 0.6,
  acidFactor: 1.0,
  blockHP: 16,
  showHP: true,
  debrisEnabled: true,
  seed: 987654321,
  grid: [], dirtGrid: [], caveMap: [],
  rainDrops: [], seepageParticles: [], balls: [],
  mountainPath: [], caveMouthPath: []
};

// ===== UTILS =====
const rng = {
  seed: 0,
  setSeed(s) { this.seed = s; state.seed = s; document.getElementById('seedInput').value = s; },
  next() {
    this.seed = (this.seed * 1664525 + 1013904223) % 4294967296;
    return (this.seed >>> 0) / 4294967296;
  }
};

const noise = {
  noise1D(x, octaves=3) {
    let amp=1, freq=1, sum=0, norm=0;
    for(let i=0; i<octaves; i++){
      sum += Math.sin(x*0.015*freq + i*1.3) * amp + Math.cos(x*0.011*freq + i*0.7)*amp*0.5;
      norm += amp; amp *= 0.5; freq *= 2;
    }
    return sum / norm;
  },
  noise2D(x, y) {
    return Math.sin(x*0.1 + y*0.1)*0.5 + Math.cos(x*0.07 - y*0.13)*0.3 + Math.sin(x*0.05 + y*0.08)*0.2;
  }
};

// ===== GENERATION =====
const gen = {
  mountains() {
    state.mountainPath = [];
    state.caveMouthPath = [];
    const ridgeY = cfg.groundY - 150;
    for(let x=0; x<=cfg.W; x+=6) {
      const n = noise.noise1D(x + rng.next()*1000, 4);
      state.mountainPath.push({x, y: ridgeY + n*40});
    }
    const caveY = cfg.groundY - 90;
    for(let x=0; x<=cfg.W; x+=6) {
      const n = noise.noise1D(x + 500 + rng.next()*1000, 3);
      state.caveMouthPath.push({x, y: caveY + n*25});
    }
  },
  cave() {
    state.caveMap = [];
    const rows = cfg.rows + cfg.dirtRows + 5;
    for(let y=0; y<rows; y++) {
      const row = [];
      for(let x=0; x<cfg.cols; x++) {
        const n = noise.noise2D((x + rng.next()*100)*0.8, (y + rng.next()*100)*0.8);
        row.push({
          isCave: n > 0.15 - y*0.02,
          x: x*cfg.blockW, y: cfg.groundY + y*cfg.blockH,
          w: cfg.blockW, h: cfg.blockH
        });
      }
      state.caveMap.push(row);
    }
  },
  grid() {
    state.grid = [];
    for(let y=0; y<cfg.rows; y++) {
      const row = [];
      for(let x=0; x<cfg.cols; x++) {
        row.push({
          hp: state.blockHP, maxHp: state.blockHP,
          x: x*cfg.blockW, y: cfg.groundY + cfg.dirtRows*cfg.blockH + y*cfg.blockH,
          w: cfg.blockW, h: cfg.blockH, broken: false
        });
      }
      state.grid.push(row);
    }
    
    state.dirtGrid = [];
    for(let y=0; y<cfg.dirtRows; y++) {
      const row = [];
      for(let x=0; x<cfg.cols; x++) {
        row.push({
          x: x*cfg.blockW, y: cfg.groundY + y*cfg.blockH,
          w: cfg.blockW, h: cfg.blockH,
          waterLevel: 0, maxWater: 100,
          falling: false, hasCollapsed: false, destroyed: false, vy: 0
        });
      }
      state.dirtGrid.push(row);
    }
  }
};

// ===== PHYSICS =====
const physics = {
  isDirtGone() {
    return state.dirtGrid.every(row => row.every(b => b.falling || b.destroyed));
  },
  checkCollapse(gridX) {
    const broken = state.grid.filter(row => row[gridX].broken).length;
    if (broken >= cfg.rows * 0.6) {
      state.dirtGrid.forEach(row => {
        const b = row[gridX];
        if (!b.falling && !b.hasCollapsed) {
          b.falling = true; b.hasCollapsed = true; b.vy = 0;
        }
      });
    }
  },
  spawnDebris(block, isDirt=false) {
    if (state.balls.length > 150) return;
    const count = isDirt ? 2 : Math.floor(3 + Math.random()*3);
    const cx = block.x + block.w/2, cy = block.y + block.h/2;
    for(let i=0; i<count; i++) {
      const r = 2 + Math.random()*(isDirt?2:3);
      state.balls.push({
        x: cx + (Math.random()-0.5)*block.w*0.3,
        y: cy + (Math.random()-0.5)*block.h*0.3,
        vx: (Math.random()-0.5)*(isDirt?3:4),
        vy: -Math.random()*(isDirt?2:4),
        r, color: isDirt ? 
          `hsl(${30+Math.random()*15},45%,${40+Math.random()*15}%)` :
          `hsl(${35+Math.random()*10},30%,${50+Math.random()*15}%)`
      });
    }
  }
};

// ===== UPDATE =====
const update = {
  rain() {
    const allDirtGone = physics.isDirtGone();
    for(let i=state.rainDrops.length-1; i>=0; i--) {
      const d = state.rainDrops[i];
      d.y += d.vy; d.vy += 0.08;

      if (!allDirtGone && d.y + d.h >= cfg.groundY) {
        const dirtY = Math.floor((d.y - cfg.groundY) / cfg.blockH);
        const gridX = Math.floor(d.x / cfg.blockW);
        if (dirtY >= 0 && dirtY < cfg.dirtRows && gridX >= 0 && gridX < cfg.cols) {
          const b = state.dirtGrid[dirtY][gridX];
          if (!b.falling) {
            b.waterLevel = Math.min(b.maxWater, b.waterLevel + 2);
            state.rainDrops.splice(i,1); continue;
          }
        }
      } else if (allDirtGone && d.y + d.h >= cfg.groundY + cfg.dirtRows*cfg.blockH) {
        const limestoneY = Math.floor((d.y - (cfg.groundY + cfg.dirtRows*cfg.blockH)) / cfg.blockH);
        const gridX = Math.floor(d.x / cfg.blockW);
        if (limestoneY >= 0 && limestoneY < cfg.rows && gridX >= 0 && gridX < cfg.cols) {
          const lb = state.grid[limestoneY][gridX];
          if (!lb.broken && lb.hp > 0) {
            lb.hp -= state.acidFactor * 1.2;
            if (lb.hp <= 0) {
              lb.broken = true;
              if (state.debrisEnabled) physics.spawnDebris(lb);
            }
            state.rainDrops.splice(i,1); continue;
          }
        }
      }
      if (d.y > cfg.H + 40) state.rainDrops.splice(i,1);
    }
  },
  seepage() {
    state.dirtGrid.forEach(row => row.forEach(b => {
      if (!b.falling && b.waterLevel > 30 && Math.random() < b.waterLevel/800) {
        state.seepageParticles.push({
          x: b.x + Math.random()*b.w, y: b.y + b.h - 5,
          vy: 0.3 + Math.random()*0.5, size: 2 + Math.random(),
          alpha: 0.6 + Math.random()*0.3
        });
        b.waterLevel -= 0.5;
      }
    }));

    for(let i=state.seepageParticles.length-1; i>=0; i--) {
      const p = state.seepageParticles[i];
      p.y += p.vy; p.vy += 0.02;
      const limestoneY = Math.floor((p.y - (cfg.groundY + cfg.dirtRows*cfg.blockH)) / cfg.blockH);
      const gridX = Math.floor(p.x / cfg.blockW);
      if (limestoneY >= 0 && limestoneY < cfg.rows && gridX >= 0 && gridX < cfg.cols) {
        const lb = state.grid[limestoneY][gridX];
        if (!lb.broken && lb.hp > 0) {
          lb.hp -= state.acidFactor * 0.3;
          if (lb.hp <= 0) {
            lb.broken = true;
            if (state.debrisEnabled) physics.spawnDebris(lb);
            physics.checkCollapse(gridX);
          }
          state.seepageParticles.splice(i,1); continue;
        }
      }
      if (p.y > cfg.H) state.seepageParticles.splice(i,1);
    }
  },
  fallingDirt() {
    state.dirtGrid.forEach(row => row.forEach(b => {
      if (b.falling && !b.destroyed) {
        b.vy += 0.6; b.y += b.vy;
        if (b.y + b.h >= cfg.H) {
          b.destroyed = true;
          if (state.debrisEnabled && state.balls.length < 100)
            physics.spawnDebris({...b, y: cfg.H-10}, true);
        }
      }
    }));
  },
  balls() {
    state.balls.forEach(p => {
      p.vy += 0.45; p.x += p.vx; p.y += p.vy;
      if (p.x - p.r < 0) { p.x = p.r; p.vx *= -0.6; }
      if (p.x + p.r > cfg.W) { p.x = cfg.W - p.r; p.vx *= -0.6; }
      if (p.y + p.r > cfg.H) {
        p.y = cfg.H - p.r; p.vy *= -0.6; p.vx *= 0.98;
        if (Math.abs(p.vy) < 0.5) p.vy = 0;
      }
    });
    for(let i=state.balls.length-1; i>=0; i--) {
      const p = state.balls[i];
      if (Math.abs(p.vx) < 0.02 && Math.abs(p.vy) < 0.02 && p.y + p.r >= cfg.H - 0.5) {
        p.r *= 0.9;
        if (p.r < 0.8) state.balls.splice(i,1);
      }
    }
    if (state.balls.length > 120) state.balls.splice(0, state.balls.length - 120);
  }
};

// ===== RENDER =====
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');

const draw = {
  mountains() {
    ctx.fillStyle = '#6f7e8a';
    ctx.beginPath();
    ctx.moveTo(0, cfg.H);
    state.mountainPath.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(cfg.W, cfg.H);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = '#2e3a43';
    ctx.beginPath();
    ctx.moveTo(0, cfg.groundY);
    state.caveMouthPath.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.lineTo(cfg.W, cfg.groundY);
    ctx.closePath();
    ctx.fill();
  },
  cave() {
    state.caveMap.forEach(row => row.forEach(cell => {
      ctx.fillStyle = cell.isCave ? '#1a1a1a' : '#2a2a2a';
      ctx.fillRect(cell.x, cell.y, cell.w, cell.h);
    }));
    const grad = ctx.createLinearGradient(0, cfg.groundY, 0, cfg.H);
    grad.addColorStop(0, 'rgba(0,0,0,0.3)');
    grad.addColorStop(1, 'rgba(0,0,0,0.7)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, cfg.groundY, cfg.W, cfg.H - cfg.groundY);
  },
  grid() {
    state.dirtGrid.forEach(row => row.forEach(b => {
      if (!b.falling) {
        const sat = b.waterLevel / b.maxWater;
        ctx.fillStyle = `rgb(${139-sat*60},${90-sat*40},${43-sat*20})`;
        ctx.fillRect(b.x+1, b.y+1, b.w-2, b.h-2);
        ctx.strokeStyle = '#5a4a2a';
        ctx.strokeRect(b.x+1, b.y+1, b.w-2, b.h-2);
        if (state.showHP && b.waterLevel > 0) {
          const bw = b.w*0.7, bh = 5;
          const bx = b.x + (b.w-bw)/2, by = b.y + b.h - bh - 4;
          ctx.fillStyle = 'rgba(0,0,0,0.12)';
          ctx.fillRect(bx, by, bw, bh);
          ctx.fillStyle = 'rgba(70,130,220,0.95)';
          ctx.fillRect(bx, by, bw*sat, bh);
        }
      }
    }));

    state.grid.forEach(row => row.forEach(b => {
      if (!b.broken && b.hp > 0) {
        const t = b.hp / b.maxHp;
        const s = Math.floor(200 - (1-t)*120);
        ctx.fillStyle = `rgb(${s},${s},${s-6})`;
        ctx.fillRect(b.x+1, b.y+1, b.w-2, b.h-2);
        ctx.strokeStyle = '#8b8b8b';
        ctx.strokeRect(b.x+1, b.y+1, b.w-2, b.h-2);
        if (state.showHP) {
          const bw = b.w*0.7, bh = 5;
          const bx = b.x + (b.w-bw)/2, by = b.y + b.h - bh - 4;
          ctx.fillStyle = 'rgba(0,0,0,0.12)';
          ctx.fillRect(bx, by, bw, bh);
          ctx.fillStyle = 'rgba(60,140,60,0.95)';
          ctx.fillRect(bx, by, bw*t, bh);
        }
      }
    }));
  },
  fallingDirt() {
    state.dirtGrid.forEach(row => row.forEach(b => {
      if (b.falling && !b.destroyed && b.y < cfg.H + 50) {
        ctx.fillStyle = '#8b5a2a';
        ctx.fillRect(b.x+1, b.y+1, b.w-2, b.h-2);
        ctx.strokeStyle = '#5a4a2a';
        ctx.strokeRect(b.x+1, b.y+1, b.w-2, b.h-2);
      }
    }));
  },
  rain() {
    ctx.fillStyle = '#2b6cff';
    state.rainDrops.forEach(d => ctx.fillRect(d.x, d.y, d.w, d.h));
  },
  seepage() {
    state.seepageParticles.forEach(p => {
      ctx.fillStyle = `rgba(70,130,220,${p.alpha})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
      ctx.fill();
    });
  },
  balls() {
    state.balls.forEach(p => {
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
      ctx.fill();
    });
  }
};

// ===== MAIN LOOP =====
function animate() {
  ctx.clearRect(0, 0, cfg.W, cfg.H);
  
  draw.mountains();
  draw.cave();

  if (state.raining) {
    const chance = state.rainIntensity * 1.6;
    if (Math.random() < chance) {
      state.rainDrops.push({
        x: Math.random()*cfg.W, y: -12,
        vy: 4 + Math.random()*2, w: 2, h: 10
      });
    }
    if (state.rainDrops.length > 1500) state.rainDrops.splice(0, state.rainDrops.length - 1500);
  }

  update.rain();
  update.seepage();
  update.fallingDirt();
  update.balls();

  draw.grid();
  draw.seepage();
  draw.fallingDirt();
  draw.rain();
  draw.balls();

  const total = state.dirtGrid.flat().reduce((sum, b) => 
    !b.falling ? sum + b.waterLevel : sum, 0);
  const count = state.dirtGrid.flat().filter(b => !b.falling).length;
  document.getElementById('waterVal').textContent = 
    (count > 0 ? (total/count).toFixed(0) : 0) + '%';

  requestAnimationFrame(animate);
}

// ===== UI =====
function toggleSettings() {
  const s = document.getElementById('settings');
  s.style.display = s.style.display === 'none' ? 'block' : 'none';
}

function reset(newSeed = Math.floor(Math.random()*1e9)) {
  rng.setSeed(newSeed);
  gen.mountains();
  gen.cave();
  gen.grid();
  state.raining = false;
  state.rainDrops = []; state.seepageParticles = []; state.balls = [];
  document.getElementById('startBtn').textContent = 'Start rain';
}

document.getElementById('startBtn').onclick = () => {
  state.raining = !state.raining;
  document.getElementById('startBtn').textContent = state.raining ? 'Stop rain' : 'Start rain';
};
document.getElementById('resetBtn').onclick = () => reset();
document.getElementById('fsBtn').onclick = () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
    document.getElementById('fsBtn').textContent = "Exit Fullscreen";
  } else {
    document.exitFullscreen();
    document.getElementById('fsBtn').textContent = "Fullscreen";
  }
};

document.getElementById('copySeedBtn').onclick = () => {
  navigator.clipboard.writeText(state.seed.toString()).then(() => {
    const btn = document.getElementById('copySeedBtn');
    const old = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = old, 1500);
  });
};
document.getElementById('applySeedBtn').onclick = () => {
  const s = parseInt(document.getElementById('seedInput').value, 10);
  if (!isNaN(s)) reset(s);
};
document.getElementById('randomSeedBtn').onclick = () => reset();

document.getElementById('rainSlider').oninput = (e) => {
  state.rainIntensity = parseFloat(e.target.value);
  document.getElementById('rainVal').textContent = state.rainIntensity.toFixed(2);
};
document.getElementById('acidSlider').oninput = (e) => {
  state.acidFactor = parseFloat(e.target.value);
  document.getElementById('acidVal').textContent = state.acidFactor.toFixed(1);
};
document.getElementById('hpSlider').oninput = (e) => {
  state.blockHP = parseInt(e.target.value, 10);
  document.getElementById('hpVal').textContent = state.blockHP;
};
document.getElementById('hpToggle').onchange = (e) => state.showHP = e.target.checked;
document.getElementById('debrisToggle').onchange = (e) => state.debrisEnabled = e.target.checked;

canvas.onclick = (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) * (cfg.W / rect.width);
  for(let i=0; i<32; i++) {
    state.rainDrops.push({
      x: x + (Math.random()-0.5)*40, y: -12,
      vy: 4 + Math.random()*2, w: 2, h: 10
    });
  }
};

// ===== INIT =====
reset(987654321);
animate();
</script>
</body>
</html>
